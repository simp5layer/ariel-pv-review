import { useCallback, useState } from 'react';
import { Deliverable, DELIVERABLE_METADATA, DeliverableType } from '@/types/project';
import { toast } from 'sonner';

const deliverableOrder: DeliverableType[] = [
  'ai_prompt_log',
  'design_review_report',
  'issue_register',
  'compliance_checklist',
  'recalculation_sheet',
  'redline_notes',
  'bom_boq',
  'risk_reflection'
];

export function useExportPackage() {
  const [isExporting, setIsExporting] = useState(false);

  const exportAsMarkdown = useCallback((
    deliverables: Deliverable[],
    projectName: string = 'Project'
  ): string => {
    const deliverableMap = new Map(deliverables.map(d => [d.type, d]));
    const timestamp = new Date().toISOString().split('T')[0];
    
    let markdown = `# Design Review Package\n\n`;
    markdown += `**Project:** ${projectName}\n`;
    markdown += `**Generated:** ${new Date().toLocaleString()}\n`;
    markdown += `**Package Version:** 1.0\n\n`;
    markdown += `---\n\n`;
    markdown += `## Table of Contents\n\n`;
    
    // Build TOC
    deliverableOrder.forEach((type, idx) => {
      const meta = DELIVERABLE_METADATA[type];
      markdown += `${idx + 1}. [${meta.name}](#${type.replace(/_/g, '-')})\n`;
    });
    
    markdown += `\n---\n\n`;
    
    // Add each deliverable
    deliverableOrder.forEach((type) => {
      const deliverable = deliverableMap.get(type);
      const meta = DELIVERABLE_METADATA[type];
      
      markdown += `## ${meta.icon} ${meta.name} {#${type.replace(/_/g, '-')}}\n\n`;
      
      if (deliverable?.content && deliverable.status !== 'not_generated') {
        // Check for error content
        if (deliverable.content.includes('could not be generated') || 
            deliverable.content.includes('INSUFFICIENT DATA')) {
          markdown += `> ⚠️ **Note:** This section contains incomplete data. Human verification required.\n\n`;
        }
        markdown += deliverable.content;
      } else {
        markdown += `> ⚠️ **Not Generated**\n>\n> This deliverable was not generated. Please run "Generate Missing Deliverables" to create this report.\n`;
      }
      
      markdown += `\n\n---\n\n`;
    });
    
    markdown += `\n## Document Footer\n\n`;
    markdown += `This document was automatically generated by the PV Design Review System.\n`;
    markdown += `All findings should be verified by a qualified engineer before implementation.\n`;
    
    return markdown;
  }, []);

  const downloadPackage = useCallback(async (
    deliverables: Deliverable[],
    projectName: string = 'Project'
  ) => {
    setIsExporting(true);
    
    try {
      // Validate all deliverables have content
      const deliverableMap = new Map(deliverables.map(d => [d.type, d]));
      const missingContent: string[] = [];
      const hasErrorContent: string[] = [];
      
      for (const type of deliverableOrder) {
        const del = deliverableMap.get(type);
        if (!del || del.status === 'not_generated' || !del.content) {
          missingContent.push(DELIVERABLE_METADATA[type].name);
        } else if (del.content.includes('could not be generated')) {
          hasErrorContent.push(DELIVERABLE_METADATA[type].name);
        }
      }
      
      if (missingContent.length > 0) {
        toast.warning(`Some deliverables are missing: ${missingContent.join(', ')}. Exporting available content only.`);
      }
      
      if (hasErrorContent.length > 0) {
        toast.warning(`Some deliverables have errors: ${hasErrorContent.join(', ')}. Please regenerate.`);
      }
      
      // Generate markdown content
      const markdown = exportAsMarkdown(deliverables, projectName);
      
      // Create blob and download
      const blob = new Blob([markdown], { type: 'text/markdown;charset=utf-8' });
      const url = URL.createObjectURL(blob);
      
      const sanitizedName = projectName.replace(/[^a-zA-Z0-9-_]/g, '_');
      const timestamp = new Date().toISOString().split('T')[0];
      const filename = `${sanitizedName}_Design_Review_Package_${timestamp}.md`;
      
      const link = document.createElement('a');
      link.href = url;
      link.download = filename;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);
      
      toast.success(`Package exported: ${filename}`);
    } catch (error) {
      console.error('Export error:', error);
      toast.error('Failed to export package');
    } finally {
      setIsExporting(false);
    }
  }, [exportAsMarkdown]);

  const canExport = useCallback((deliverables: Deliverable[]): boolean => {
    // Can export if at least some deliverables have content
    return deliverables.some(d => d.status !== 'not_generated' && d.content);
  }, []);

  const getExportStatus = useCallback((deliverables: Deliverable[]): {
    ready: number;
    total: number;
    complete: boolean;
    hasErrors: boolean;
  } => {
    const deliverableMap = new Map(deliverables.map(d => [d.type, d]));
    let ready = 0;
    let hasErrors = false;
    
    for (const type of deliverableOrder) {
      const del = deliverableMap.get(type);
      if (del && del.status !== 'not_generated' && del.content) {
        ready++;
        if (del.content.includes('could not be generated')) {
          hasErrors = true;
        }
      }
    }
    
    return {
      ready,
      total: deliverableOrder.length,
      complete: ready === deliverableOrder.length,
      hasErrors
    };
  }, []);

  return {
    downloadPackage,
    exportAsMarkdown,
    canExport,
    getExportStatus,
    isExporting
  };
}
